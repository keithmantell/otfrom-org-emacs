* Helpers

  There are a number of helper functions that we'll need through the
  rest of this. We'll just define them up here.

** load-if-exists

   This is just a nice function to load a file if it exists, but just
   print a message rather than an error if it doesn't. This is handy
   for things like loading specific local config that you don't want
   to go into github or be shared such as erc nicks, passwords, blog
   rolls, etc.

   #+BEGIN_SRC emacs-lisp
     (defun load-if-exists (file)
       (if (file-exists-p file)
           (progn
             (load file)
             (message (format "Loading file: %s" file)))
         (message (format "No %s file. So not loading one." file))))
   #+END_SRC

* Starting

  There are some variables we'll really want to set up before
  everything gets kicked off. Usually we'd want to do this by using
  the :config key in use-package, but sometimes, I'm not smart enough
  to know how to do it.

** We need diminish

   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :ensure t)
   #+END_SRC

** My elisp wip

   Things I'm working on that may one day end up in melpa.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/wip/")
   #+END_SRC

** Backups

   Backups are handy for those times where you run out of power
   suddenly or you get a kernel panic, but it isn't fun having them
   littered around the system.

   #+BEGIN_SRC emacs-lisp
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
   #+END_SRC

** Enabling the disabled

*** upcase and downcase region

    I like to be able to do this. I get lots of things that come in
    SHOUTING or that need to SHOUT.

    #+BEGIN_SRC emacs-lisp
      (put 'downcase-region 'disabled nil)
      (put 'upcase-region 'disabled nil)
    #+END_SRC

*** Narrowing the region to what I want to look at

    This isn't needed quite so much now that searches, regexp and
    otherwise operate, sometimes annoyingly to an old timer like me, on
    the region rather than the whole buffer window. I still like to
    narrow down to what I'm interested in though and not every handy
    tool in emacs is quite so region oriented.

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

** custom.el

   custom.el is great for configuring things through that "gui" in
   emacs, but it is a real pain when it drops junk in your [[../init.el][init.el]] and
   messes up your pretty config and git history and is stuff that you
   don't want to leak out on to github. You can change the location of
   this file though and I like to do this.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "local/custom.el"))
     (load-if-exists custom-file)
   #+END_SRC

** passwords and encrypted things

   It is good to store your passwords and things in an encrypted
   file. I call mine mellon, because you can only read it if you are
   my friend and have the passphrase.

   This does mean that every time you use it you have to give the
   passphrase, but it does mean that you can keep all your passwords
   for things like erc and stuff in a file reasonably safely (though
   it will be in memory when emacs is running, so it isn't completely
   secure).

   #+BEGIN_SRC emacs-lisp
     (load-if-exists (concat user-emacs-directory "local/mellon.el.gpg"))
   #+END_SRC


*** Let's use ~/.netrc tool

    #+BEGIN_SRC emacs-lisp
      (use-package netrc)
    #+END_SRC

* Version Control and diff

  Once we have things up and running, really the most basic thing is
  version control. This allows us to add everything else we need in an
  organised manner. Once we have this we can bootstrap everything
  else.

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :bind (("C-c g" . magit-status)))
  #+END_SRC

  And as we love org and love magit we want to be able to have
  todo.org files in our git repos so that we can see what we still
  have to do.

  #+BEGIN_SRC emacs-lisp
    (use-package magit-org-todos
      :ensure t
      :config
      (magit-org-todos-autoinsert))
  #+END_SRC

  And why limit ourselves to just todos in a todo.org? We can find all
  the todos, hacks and fixmes using [[https://github.com/alphapapa/magit-todos][magit-todo]].

  #+BEGIN_SRC emacs-lisp
    (use-package magit-todos
      :ensure t)
  #+END_SRC

  Once we do have version control and can do things with ediff, which
  is a great mode for looking at diffs between versions, buffer, files
  and directory trees, I want to fix how the windows work as the
  default annoys me when it creates separate frames. I'd much rather
  move around windows inside the one emacs frame.

  #+BEGIN_SRC emacs-lisp
    (use-package ediff
      :config
      (setq ediff-window-setup-function 'ediff-setup-windows-plain))
  #+END_SRC

** link to github

   #+BEGIN_SRC emacs-lisp
     (use-package git-link
       :ensure t)
   #+END_SRC

** Step through those versions of a file with the time machine

   #+BEGIN_SRC emacs-lisp
     (use-package git-timemachine
       :ensure t)
   #+END_SRC

** See last commit for this line in a popup

   #+BEGIN_SRC emacs-lisp
     (use-package git-messenger
       :ensure t)
   #+END_SRC

** Delete that trailing whitespace

   Trailing whitespace just causes trouble with diffs and version
   control. So let's get rid of it.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook
               (lambda nil
                 (delete-trailing-whitespace)))
   #+END_SRC

** Git Auto Commit

   There are some things, like my personal and work org trees, where I
   want to keep versions in case I mess anything up and need to repair
   anything, but don't really want to do proper thought through
   version control. Emacs of course makes this possible.

   #+BEGIN_SRC emacs-lisp
     (use-package git-auto-commit-mode
       :ensure t)
  #+END_SRC

* Make it pretty

** Colours

   It seems trivial, but it is one of the first things I do after I
   get the basics up and running. I like to get my colours and other
   basic window chrome and geegaws right.

   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-sanityinc-tomorrow
       :ensure t
       :load-path "themes"
       :config
       (load-theme 'sanityinc-tomorrow-bright t))
   #+END_SRC

** Bars, columns and lines

   I don't want a tool bar or a scroll bar ever and I don't want a
   menu when I'm in a terminal window.  I do like the menu ot discover
   new things and keybindings when I'm using emacs as an X
   application.

   #+BEGIN_SRC emacs-lisp
     ;; no toolbar
     (tool-bar-mode -1)

     ;; no menu in a terminal
     (unless window-system
       (menu-bar-mode -1))

     ;; no scroll bar
     (scroll-bar-mode -1)

     ;; no horizontal scroll bar
     (when (boundp 'horizontal-scroll-bar-mode)
       (horizontal-scroll-bar-mode -1))
   #+END_SRC

   I also like to have an idea of where I am in the file so I'd like
   line and column numbers.

   #+BEGIN_SRC emacs-lisp
     (size-indication-mode 1)
     (line-number-mode 1)
     (column-number-mode 1)
   #+END_SRC

** powerline

   #+BEGIN_SRC emacs-lisp
     (use-package powerline
       :ensure t
       :config (powerline-default-theme))
   #+END_SRC

** Beacon

   Make with the wooshy cursor to see where it is

   #+BEGIN_SRC emacs-lisp
     (blink-cursor-mode -1)

     (use-package beacon
       :diminish
       :ensure t
       :config
       (beacon-mode 1))
   #+END_SRC

** Startup Screen

   I'd also like to skip the startup screen and go straight to the
   *scratch* buffer.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
   #+END_SRC

* Programming

  Configuring emacs is lisp coding. When I'm not coding in emacs-lisp,
  I'm usually coding in clojure. I'd like to try to get get nice
  environments for both as quickly as possible.

** Helping in all modes

   Some minor modes just help with programming everywhere.

*** company

    This is the best completion package available in emacs at the
    moment. It works with most programming modes.

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :config
        (global-company-mode))
    #+END_SRC

*** Faster searching with ag

    #+BEGIN_SRC emacs-lisp
      (use-package ag
        :ensure t)
    #+END_SRC

*** projectile

    Projectile allows you to treat gropus of files under git control
    or other build tools as projects and navigate and search them in
    easier ways.

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :diminish projectile-mode
        :config
        (setq projectile-enable-caching t)
        (projectile-global-mode 1))
    #+END_SRC

*** tabs are evil

    They are, they just are. I spent time putting those characters in
    the right place. I don't want you to change that.

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+END_SRC

*** whitespace mode

    You never know when the evils of whitespace might be around. When
    will it catch you out?

    #+BEGIN_SRC emacs-lisp
      (use-package whitespace
        :diminish whitespace-mode
        :init (setq whitespace-style '(face tabs trailing))
        :config (global-whitespace-mode t))
    #+END_SRC

*** flycheck

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :hook ((sh-mode) . flycheck-mode))
    #+END_SRC

*** Highlight the symbol you are on

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-symbol
        :ensure t
        :diminish highlight-symbol-mode
        :hook (prog-mode . highlight-symbol-mode)
        :config
        (setq highlight-symbol-on-navigation-p t))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-symbol-nav-mode
        :hook (prog-mode . highlight-symbol-nav-mode))
    #+END_SRC

*** ivy-xref

    #+BEGIN_SRC emacs-lisp
      (use-package ivy-xref
        :ensure t
        :config (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
    #+END_SRC

** Lisps

   I am a big fan of lisps. I like the syntax and some of the
   communities now a days are very nice places to be in.

   At the moment most of my lisp work is either in emacs-lisp or in
   clojure.

   Below are the ways I configure various lisp modes.

*** Indent all the things... aggressively
    :PROPERTIES:
    :ID:       af5cff8f-a275-46b2-ae45-70ab8ad59ac4
    :END:

    I love this mode when doing lisp stuff. It really makes it
    obvious when you don't have things balanced up and keeps your
    code tidy.

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :ensure t
        :diminish aggressive-indent-mode
        :hook ((emacs-lisp-mode lisp-mode clojure-mode) . aggressive-indent-mode))
    #+END_SRC

*** eldoc so you know what is going on

    eldoc is another great little tip so that you can see what the
    signature is for the functions you are using.

    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :diminish eldoc-mode
        :hook ((emacs-lisp-mode lisp-mode clojure-mode) . eldoc-mode))
    #+END_SRC

*** paredit

    I *always* want my parens to match (except in text modes).

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t
        :diminish paredit-mode
        :hook ((lisp-mode cider-mode emacs-lisp-mode cider-repl-mode) . paredit-mode))
    #+END_SRC

*** rainbow delimiters

    All of those delimeters should be pretty and give you a hint as
    to where they match.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :diminish rainbow-delimiters
        :hook ((lisp-mode cider-mode emacs-lisp-mode cider-repl-mode) . rainbow-delimiters-mode))
    #+END_SRC

*** Paren matching

    Because you really need to see where those things match.

    #+BEGIN_SRC emacs-lisp
      (use-package paren
        :hook ((lisp-mode cider-mode clojure-mode emacs-lisp-mode cider-repl-mode) . show-paren-mode))
    #+END_SRC

*** clojure and CIDER

    Clojure is certainly my favorite lisp on the JVM and is the one I
    use most professionally, or at least the one I create code in that
    I ship to other people.

    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :defer t
        :mode (("\\.clj\\'" . clojure-mode)
               ("\\.edn\\'" . clojure-mode)))
    #+END_SRC

    CIDER is the mode that lets us connect to a REPL and evaluate code
    and do REPL Driven Development.

    #+BEGIN_SRC emacs-lisp
      (use-package cider
        :ensure t
        :defer t
        :init
        (setq cider-lein-parameters "repl :headless :host localhost"
              cider-repl-history-file (concat user-emacs-directory "cider-history")
              cider-repl-history-size 1000
              cider-font-lock-dynamically '(macro core function var)
              cider-overlays-use-font-lock t
              cider-pprint-fn 'fipp
              cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))"))
    #+END_SRC

    clj-refactor lets us move a lot of things around and get less
    often used bits of syntax like ns declrations correct.

    #+BEGIN_SRC emacs-lisp
      ;; (use-package clj-refactor
      ;;   :ensure t
      ;;   :defer t
      ;;   :config
      ;;   (defun my-clj-refactor-hook ()
      ;;     (message "Running cljr hook.")
      ;;     (clj-refactor-mode 1)
      ;;     (cljr-add-keybindings-with-prefix "C-c r"))
      ;;   (add-hook 'clojure-mode-hook 'my-clj-refactor-hook))
    #+END_SRC

**** joker and linting

     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-joker
         :ensure t)
     #+END_SRC

** Scala

   Yeah, I'll have a java mode here too at some point.

   #+BEGIN_SRC emacs-lisp
     (use-package ensime
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** R

   I've always found emacs speaks statistics to be a bit
   intimidating.

   #+BEGIN_SRC emacs-lisp
     (use-package ess
       :ensure t)
   #+END_SRC

** Ops Stuff
*** Docker

    DOCKER ALL THE THINGS!!!!

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :ensure t)
    #+END_SRC

*** Terraform

    Highlight the syntax of those terraform files.

    #+BEGIN_SRC emacs-lisp
      (use-package terraform-mode
        :ensure t)
    #+END_SRC

** YAML

   So many bad things have been done with YAML. It is less verbose
   than JSON or XML, but I'm not sure it is really better.

   #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :ensure t)
   #+END_SRC

** plantuml

   #+BEGIN_SRC emacs-lisp
     (use-package plantuml-mode
       :ensure t
       :init
       (setq plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
       (setq org-plantuml-jar-path plantuml-jar-path))

     (use-package flycheck-plantuml
       :ensure t
       :config
       (flycheck-plantuml-setup))
   #+END_SRC

** graphviz

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure t)
   #+END_SRC

** jenkins

#+BEGIN_SRC emacs-lisp
  (use-package jenkins
    :ensure t)
#+END_SRC

** sql

   Formatting SQL is a pain

   #+BEGIN_SRC emacs-lisp
     (use-package sql-indent
       :ensure t)
   #+END_SRC

* Text Modes

** Text Mode Basics

   If we are in a text mode we want flyspell and auto-fill-mode.

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :diminish flyspell-mode
       :config (add-hook 'text-mode-hook
                         (lambda () (flyspell-mode 1))))
   #+END_SRC

   auto-fill-mode & text-mode is a bit weird and I've really not found
   a way to make it play nicely with use-package they way I've done
   the other minor modes. So I've just gone old school here.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook
               (lambda ()
                 (auto-fill-mode 1)
                 (diminish auto-fill-function)))
   #+END_SRC

** org-mode

   This mode is so powerful, I like to program in it. :-D

*** org-mode tweaks

    There a soooo many things to configure in org-mode. Here are some
    of the ones that are core to me.

    #+BEGIN_SRC emacs-lisp
      (eval-after-load "org"
        '(progn (setq org-log-done 'note)         ; log when we finish things
                (setq org-log-into-drawer t) ; put log into the drawer
                (setq org-default-notes-file "~/org/capture/todos.org")
                (setq org-clock-persist 'history)
                (setq org-link-search-must-match-exact-headline nil) ;; fuzzy match headlines
                (setq org-agenda-window-setup 'current-window) ; agenda in current window
                (org-clock-persistence-insinuate) ; keep the clock history
                (require 'org-habit) ; track habits
                (appt-activate 1))) ; shout when we have appts


      (setq org-use-fast-todo-selection t)
      (setq org-todo-keywords
            '((sequence "UPCOMING(u)" "PROJECT(p)" "|" "SHIPPED(s)")
              (sequence "TODO(t)" "NEXT(n!/!)" "STARTED(r)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "INACTIVE(i@/!)" "|" "CANCELLED(c@/!)" "MEETING")))

      (setq org-todo-state-tags-triggers
            '(("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("INACTIVE" ("WAITING") ("INACTIVE" . t))
              (done ("WAITING") ("INACTIVE"))
              ("TODO" ("WAITING") ("CANCELLED") ("INACTIVE"))
              ("NEXT" ("WAITING") ("CANCELLED") ("INACTIVE"))
              ("DONE" ("WAITING") ("CANCELLED") ("INACTIVE"))))


      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "<f12>") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)
      (global-set-key (kbd "C-<f12>") 'org-agenda) ;; change this to switch or new
      (define-key org-agenda-mode-map "y" 'org-store-link)
    #+END_SRC

**** IDs for everything
     :PROPERTIES:
     :ID:       18578255-c92e-42ab-b4e4-a687d444e87a
     :END:

     If you have IDs, then you don't need to worry about headings
     having the same text or if they move around.

     #+BEGIN_SRC emacs-lisp
       (use-package org-id
         :init
         (setq org-id-link-to-org-use-id t))
     #+END_SRC

*** org-mode add ons
**** org-gcal

     I'd like to have my Google Calendar events in org-mode agenda
     buffers. This isn't because I particularly like Google Calendar,
     but it is a convenient way to share my schedule with my
     colleagues, friends and customers.

     #+BEGIN_SRC emacs-lisp
       (use-package org-gcal
         :ensure t)
     #+END_SRC

     And a way to update everything and get things in appt.

     #+BEGIN_SRC emacs-lisp
       (defun update-agenda ()
         (interactive)
         (org-gcal-fetch)
         (setq appt-time-msg-list nil)
         (org-agenda-redo-all)
         (org-agenda-to-appt))
     #+END_SRC

**** org-journal

     When I'm not trying to actually follow a procedure around using
     org-mode for day to day stuff, I basically follow the pattern
     [[https://github.com/bastibe/][bastibe]] talks about [[https://github.com/bastibe/org-journal][here]].

     I've tried gtd things, deft, using org-capture and refile and I've
     never really stuck with any of them. The one that did work very
     well for me was the predecessor to org-mode [[https://www.emacswiki.org/emacs/PlannerMode][planner-mode]].

     I've also been reading about PARA and BASB and I think that having
     a log with tags and then things moving into particular projects
     and areas gives me what I need.

     #+BEGIN_SRC emacs-lisp
       (use-package org-journal
         :ensure t
         :bind (("C-c j" . org-journal-new-entry))
         :init
         (setq org-journal-dir "~/org/journal/"
               org-journal-enable-agenda-integration t
               org-journal-carryover-items "TODO=\"WAITING\"|TODO=\"STARTED\"|TODO=\"TODO\"|TODO=\"NEXT\"")
         (add-to-list 'auto-mode-alist '("org/journal" . org-mode)))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (defun work-browser (url &optional _new-window)
         (interactive (browse-url-interactive-arg "URL: "))
         (setq url (browse-url-encode-url url))
         (let ((process-environment (browse-url-process-environment)))
           (apply 'start-process
                  (concat "chrome " url) nil
                  browse-url-chrome-program
                  (list "--profile-directory=Profile 1" "--new-window" url))))

       (defun personal-browser (url &optional _new-window)
         (interactive (browse-url-interactive-arg "URL: "))
         (setq url (browse-url-encode-url url))
         (let ((process-environment (browse-url-process-environment)))
           (apply 'start-process
                  (concat "chrome " url) nil
                  browse-url-chrome-program
                  (list "--profile-directory=Default" "--new-window" url))))
     #+END_SRC

**** org-super-agenda

     Lots of examples [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org][here]].

     #+BEGIN_SRC emacs-lisp
       (use-package org-super-agenda
         :ensure t)
     #+END_SRC

**** org-web-tools

     Something like pocket, but in org-mode and locally. This might be
     the start of my own outboard brain. I just need to figure out how
     to make it work well with org-capture.

     #+BEGIN_SRC emacs-lisp
       (use-package org-web-tools
         :ensure t)
     #+END_SRC

**** org-clock-today

     How much time have I clocked today?

     #+BEGIN_SRC emacs-lisp
       (use-package org-clock-today
         :ensure t)
     #+END_SRC

**** Interleave

     Could this be the best way to take notes on pdfs?

     #+BEGIN_SRC emacs-lisp
       (use-package interleave
         :ensure t
         :config (setq interleave-org-notes-dir-list '("~/org/interleave" ".")))
     #+END_SRC

**** org-babel

     I want to be able to do shell and have graphviz and plantuml
     visualisations in my org-mode buffers (this is where I do a lot of
     my thinking).

     For some of the longer running things though I want them to be
     asynchronous so they don't tie up my emacs while they are running
     in the background.

     #+BEGIN_SRC emacs-lisp
       (use-package ob-async
         :ensure t)
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((shell . t)
          (dot . graphviz-dot)
          (plantuml . t)))
     #+END_SRC

**** Preview org-mode pages as html

     I'm hoping this will be handy for copying and pasting org-mode
     stuff into emails and google docs for sharing with unbelievers.

     #+BEGIN_SRC emacs-lisp
       (use-package org-preview-html
         :ensure t)
     #+END_SRC

**** clipboard URLs to org-mode

     I'm a real pack rat when it comes to book marking things. I've
     always wanted to have them integrated with everything else and
     under my control. I'm hoping that org-cliplink will help with
     that.

     #+BEGIN_SRC emacs-lisp
       (use-package org-cliplink
         :ensure t)
     #+END_SRC

**** org2blog

     #+BEGIN_SRC emacs-lisp
       (use-package org2blog
         :ensure t
         :config (setq org2blog/wp-use-sourcecode-shortcode nil
                       org2blog/wp-blog-alist
                       (->> (netrc-parse "~/.netrc")
                            (-filter #'(lambda (m) (string-match-p "wordpress.com" (cdr (assoc "machine" m)))))
                            (mapcar
                             #'(lambda (m)
                                 (list (cdr (assoc "machine" m))
                                       :url (concat "https://" (cdr (assoc "machine" m)) "/xmlrpc.php")
                                       :username (cdr (assoc "login" m))
                                       :password (cdr (assoc "password" m))))))))
     #+END_SRC

**** mailbox like rescheduling.

     mailbox is gone -- a victim of the M&A wars. We can still carry on
     with the ideas though due to the power of Free Software.

     #+BEGIN_SRC emacs-lisp
       (use-package orgbox
         :ensure t)
     #+END_SRC

**** split those clock entries

     For when you need to edit the past b/c a clock has run on for too
     long. More details on the [[https://github.com/justintaft/org-clock-split][github]].

     #+BEGIN_SRC emacs-lisp
       (use-package org-clock-split
         :ensure t)
     #+END_SRC

*** org agenda

    These are the files that I currently need to keep an up to date
    integrated agenda.

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files
            (append
             (file-expand-wildcards "~/org/capture/*.org")
             (file-expand-wildcards "~/org/work/*.org")
             (file-expand-wildcards "~/org/life/*.org")
             (mapcar 'cdr org-gcal-file-alist)))
    #+END_SRC

    I want the timeclock report to show me hours and not days.

    #+BEGIN_SRC emacs-lisp
      (setq org-time-clocksum-format
            (quote (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))
    #+END_SRC

*** org agenda clock editing

    There are a lot of interesting things [[https://github.com/dfeich/org-clock-convenience][here]] about editing and
    tracking time in org-agenda files.

    #+BEGIN_SRC emacs-lisp
      (use-package org-clock-convenience
        :ensure t
        :config
        (defun dfeich/org-agenda-mode-fn ()
          (define-key org-agenda-mode-map
            (kbd "<S-up>") #'org-clock-convenience-timestamp-up)
          (define-key org-agenda-mode-map
            (kbd "<S-down>") #'org-clock-convenience-timestamp-down)
          (define-key org-agenda-mode-map
            (kbd "ø") #'org-clock-convenience-fill-gap)) ; AltGr-o
        (add-hook 'org-agenda-mode-hook #'dfeich/org-agenda-mode-fn))
    #+END_SRC

*** Custom Agenda Views

    The default agenda is a good start, but we can do a bit better.

**** What am I doing in the Current Cake Countdown?
     :PROPERTIES:
     :ID:       08f62b57-c7b5-47c2-bd72-3244336b923b
     :END:

     The todo items are also filtered to only show things that have
     the Owner property set to my name.

     I'm using [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] now as it gives me a lot of
     flexibility around sections. There are instructions on how to
     configure it in the [[https://github.com/alphapapa/org-super-agenda/blob/master/README.org][readme]] and [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org][examples]].

     #+BEGIN_SRC emacs-lisp
       (add-to-list
        'org-agenda-custom-commands
        '("M" "Super Agenda" agenda
          (org-super-agenda-mode)
          ((org-super-agenda-groups
            '((:log t)  ; Automatically named "Log"
              (:name "Schedule"
                     :time-grid t
                     :order 10)
              (:name "Started"
                     :todo ("STARTED")
                     :order 20)
              (:name "Overdue"
                     :deadline past
                     :order 30)
              (:name "Due today"
                     :deadline today
                     :order 40)
              (:name "Waiting..."
                     :todo "WAITING"
                     :order 50)
              (:name "Today"
                     :scheduled today
                     :order 60)
              (:habit t
                      :order 70)
              (:name "Due soon"
                     :deadline future
                     :order 80)
              (:name "Scheduled earlier"
                     :scheduled past
                     :order 90)
              (:name "Unimportant"
                     :todo ("SOMEDAY" "MAYBE" "CHECK" "TO-READ" "TO-WATCH")
                     :order 100))))
          (org-agenda nil "a")))
     #+END_SRC

**** Holidays

     From the help-gnu-emacs [[https://lists.gnu.org/archive/html/help-gnu-emacs/2014-08/msg00093.html][list]].

     And more details from the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Holiday-Customizing.html][GNU Emacs Manual]].

     #+BEGIN_SRC emacs-lisp
       (setq calendar-date-style 'european)
     #+END_SRC

     #+BEGIN_EXAMPLE
       Hmmm, a very quick try:
       Holidays from:
       https://en.wikipedia.org/wiki/Public_holidays_in_the_United_Kingdom

       Put this in your .emacs, restart, and give it a try:

       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq european-calendar-style t             ; obsolete!
             calendar-date-style 'european
                                               ;        calendar-latitude
                                               ;        calendar-longitude
             calendar-week-start-day 1
             mark-holidays-in-calendar t
             ;; remove some holidays
             all-christian-calendar-holidays nil         ;obsolete
             calendar-christian-all-holidays-flag nil
             general-holidays t
             hebrew-holidays nil
             islamic-holidays nil
             oriental-holidays nil
             bahai-holidays nil)

       (setq holiday-general-holidays
             '((holiday-fixed 1 1 "New Year's Day")
               (holiday-fixed 3 17 "St. Patrick's Day")
               (holiday-float 5 1 1 "May Day Bank Holiday")
               (holiday-fixed 7 12 "Battle of the Boyne")
               (holiday-float 8 1 -1 "May Day Bank Holiday")
               (holiday-fixed 12 26 "Boxing Day")))

       (setq holiday-christian-holidays
             '((holiday-fixed 12 25 "Christmas Day")
               (holiday-easter-etc  -2 "Good Friday")
               (holiday-easter-etc  +1 "Easter Monday")))

       (setq calendar-holidays
             (append general-holidays
                     christian-holidays))

       (setq org-agenda-include-diary t)
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     #+END_EXAMPLE

**** Pomodoro in agenda

     Something to keep me focused and take breaks when I am focused
     (so I don't die from sitting in one place for too long).

     #+BEGIN_SRC emacs-lisp
       (use-package org-pomodoro
         :ensure t
         :config
         (add-hook 'org-agenda-mode-hook
                   (lambda () (local-set-key (kbd "P") 'org-pomodoro))))
     #+END_SRC

*** Capturing & Refiling
    :PROPERTIES:
    :ID:       d5a6a956-3d13-424c-83c7-63743b8132a7
    :END:

    My thinking at the moment is that I'll take day notes in
    org-journal, have a wiki like thing in other org files and
    interleave (and use org links to keep them all together under my
    org-directory) and have a todos.org file which will have all my
    other todo goodies which I can capture from other files, pivotal
    tracker stuff or from the journal itself which should make it so
    my todos always point back to where they initially came from.

    We'll see if it works for now.

    #+BEGIN_SRC emacs-lisp
      ;; from https://github.com/bastibe/org-journal#journal-capture-template
      (defun org-journal-find-location ()
        ;; Open today's journal, but specify a non-nil prefix argument in order to
        ;; inhibit inserting the heading; org-capture will insert the heading.
        (org-journal-new-entry t)
        ;; Position point on the journal's top-level heading so that org-capture
        ;; will add the new entry as a child entry.
        (goto-char (point-min)))

      (setq org-capture-templates
            '(("t" "To do"
               entry (function org-journal-find-location)
               "* TODO %?\n%U\n%a\n"
               :empty-lines-before 1)
              ("p" "To do from Pivotal"
               entry (function org-journal-find-location)
               "* TODO %:description :pivotal:\n%U\n%a\n%?"
               :empty-lines-before 1)
              ("d" "Daily Review"
               entry (function org-journal-find-location)
               "* STARTED Daily Review [/]\n%U\n%a\n\n%?%[~/.emacs.d/org/daily-review.org]"
               :clock-in t :clock-resume t
               :empty-lines-before 1)
              ("y" "Weekly Review"
               entry (function org-journal-find-location)
               "* STARTED Weekly Review [/]\n%U\n%a\n\n%?%[~/.emacs.d/org/weekly-review.org]"
               :clock-in t :clock-resume t
               :empty-lines-before 1)
              ("w" "To do from the web"
               entry (function org-journal-find-location)
               "* TODO %?\n%U\n%(org-cliplink-capture)\n"
               :empty-lines-before 1)
              ("r" "Capture Web site with eww-readable"
               entry (function org-journal-find-location)
               "%(org-web-tools--url-as-readable-org)")
              ("n" "Doing RIGHT NOW"
               entry (function org-journal-find-location)
               "* STARTED %?\n%U\n%a\n"
               :clock-in t :clock-resume t
               :empty-lines-before 1)
              ("k" "Kaylee Checks"
               entry (function org-journal-find-location)
               "* STARTED Kaylee Checks\n%U\n%a\n%?%[~/wip/kaylee-tools/org/kaylee-template.org]"
               :clock-in t :clock-resume t
               :empty-lines-before 1)
              ("c" "Contacts"
               entry (file "~/org/non-agenda/contacts.org")
               "* %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:PHONE:\n:ALIAS:\n:NICKNAME:\n:IGNORE:\n:ICON:\n:NOTE:\n:ADDRESS:\n:BIRTHDAY:\n:LAST_READ_MAIL:\n:END:"
               :empty-lines-before 1)
              ("l"
               "Capture a link"
               entry (function org-journal-find-location)
               "* %(org-cliplink-capture) %^g\n%?"
               :empty-lines-before 1)))
     #+END_SRC

**** Refiling

     I've never really been terribly happy with how this works. This
     might be a reasonable start though.

     #+BEGIN_SRC emacs-lisp
       ;;(setq org-refile-allow-creating-parent-nodes t)
       (setq org-refile-use-outline-path 'file)
       (setq org-outline-path-complete-in-steps nil)

       (setq org-refile-targets
             '((nil :maxlevel . 9)
               (org-agenda-files :maxlevel . 9)))
       ;; (setq org-refile-use-outline-path t)

       ;; (setq org-link-search-must-match-exact-headline nil)
     #+END_SRC

** Markdown

   Not everything is done in org-mode. Though perhaps it should be.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode (".md$" . gfm-mode))
   #+END_SRC

** html, css, sass, scss and others

*** rainbow-mode

    I want to see what those colours look like right in the buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
        :ensure t)
    #+END_SRC

*** tagedit

    I miss paredit when working in sgml languages. Let's fix that.

    #+BEGIN_SRC emacs-lisp
      (use-package tagedit
        :ensure t
        :commands tagedit-mode
        :config
        (tagedit-add-paredit-like-keybindings)

        (add-hook 'sgml-mode-hook 'tagedit-mode)
        (add-hook 'html-mode-hook 'tagedit-mode))
    #+END_SRC

*** scss

    Some of my projects depend on scss and sass.

    #+BEGIN_SRC emacs-lisp
      (use-package scss-mode
        :ensure t)
    #+END_SRC

** unfill - the lpad of emacs lisp?

   I may regret this, but I actually want it for copying and pasting
   from emacs into other things that don't want lines filled nicely.

   #+BEGIN_SRC emacs-lisp
     (use-package unfill
       :ensure t)
   #+END_SRC

** Convert them all with pandoc

   #+BEGIN_SRC emacs-lisp
     (use-package pandoc-mode
       :ensure t
       :hook ((markdown-mode) . pandoc-mode))
   #+END_SRC

* News, Weather and Light Entertainment

** pocket reader

   When browsing twitter if I don't bookmark something in org I like
   to put it into pocket so I can read it later. Luckily I can know
   read this in emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package pocket-reader
       :ensure t)
   #+END_SRC

** elfeed

   There are still a lot of good blogs out there. I do get tickled
   sometimes that people call blog posts "long reads"

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed-org
     :ensure t
     :init (elfeed-org)
     :config (setq rmh-elfeed-org-files (list "~/org/elfeed.org")))
   #+END_SRC

** What is the weather?

   This probably falls under "more stupid emacs tricks", but who
   wouldn't want to to see the weather in emacs?

   #+BEGIN_SRC emacs-lisp
     (use-package wttrin
       :ensure t
       :commands (wttrin)
       :init
       (setq wttrin-default-cities '("London"
                                     "Dundee")
             wttrin-default-accept-language '("Accept-Language" . "en-GB")))
   #+END_SRC

   or we can open up a browser and look at darksky.net

   #+BEGIN_SRC emacs-lisp
     (defun dundee-darksky ()
       (interactive)
       (browse-url-chrome "https://darksky.net/forecast/56.46,-2.9933/uk212/en" t))
   #+END_SRC

** twittering-mode

   I have been accused by many ([[http://twitter.com/rrees][Robert Rees]] and [[http://twitter.com/cluttercup][Jane Dickson]] to name
   but two) of being constantly on twitter. This is mostly fair. I'm
   curious to see the revision history of this file and see if I
   change this description before I declare .emacs bankruptcy again.

   The best twitter client I've found is twittering-mode.

   #+BEGIN_SRC emacs-lisp
     (use-package twittering-mode
       :ensure t
       :defer t
       :bind (([M-f6] . twittering-update-status-interactive))
       :config (setq twittering-username "otfrom"
                     twittering-url-show-status nil
                     twittering-icon-mode 1
                     twittering-use-icon-storage t
                     twittering-use-master-password t
                     twittering-connection-type-order '(wget curl urllib-http native urllib-https)
                     twittering-initial-timeline-spec-string
                     '("otfrom/people-i-know"
                       ":replies"
                       ":direct_message_events")
                     twittering-timer-interval (* 60 30))
       (add-hook 'twittering-edit-mode-hook
                 (lambda () (ispell-minor-mode) (flyspell-mode))))
   #+END_SRC

** irc/slack and erc stuff

   erc can be used for irc and as a slack client. It needs a few
   things to make it a bit nicer even though it is actually pretty
   good out of the box.

   #+BEGIN_SRC emacs-lisp
     (use-package erc-colorize
       :ensure t
       :defer t
       :config (erc-colorize-mode 1))
   #+END_SRC

** music and sound

   Yeah, I play music from inside emacs. What of it?

   #+BEGIN_SRC emacs-lisp
     (use-package emms
       :ensure t
       :config
       (progn
         (emms-standard)
         (emms-default-players)
         (setq emms-playlist-buffer-name "Music-EMMS")
         (setq emms-source-file-default-directory (concat (getenv "HOME") "/Music/"))
         (emms-mode-line 0)))
   #+END_SRC

*** I miss big thunderstorms

    Sometimes I need to concentrate and I don't want to be engaged by
    music but just white noise won't do. I like a thunderstorm for
    that.

    #+BEGIN_SRC emacs-lisp
      (defun make-it-rain ()
        (interactive)
        (emms-play-file (concat user-emacs-directory "resources/16480__martin-lightning__severe-thunderstorm.mp3")))
    #+END_SRC

* Other Modes

** make dired pretty

   Who doesn't want all the icons?

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-dired
       :ensure t
       :hook ((dired-mode) . all-the-icons-dired-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-ivy
       :ensure t
       :config
       (all-the-icons-ivy-setup))
   #+END_SRC

** ivy, swiper and others

   Shamelessly stolen from [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-ivy.el][here]].

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :ensure t)

     (use-package swiper
       :ensure t)

     (use-package ivy
       :ensure t
       :diminish ivy-mode
       :init (setq ivy-use-virtual-buffers t
                   ivy-count-format "(%d/%d) ")
       (global-set-key (kbd "C-s") 'swiper)
       (global-set-key (kbd "M-x") 'counsel-M-x)
       (global-set-key (kbd "C-x C-f") 'counsel-find-file)
       (global-set-key (kbd "<f1> f") 'counsel-describe-function)
       (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
       (global-set-key (kbd "<f1> l") 'counsel-find-library)
       (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
       (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
       :config (ivy-mode 1))
   #+END_SRC

** ibuffer

   I've never used ibuffer much before, but many people swear by it
   (rather than at it). I've tried it now and it looks good. So let's
   rebind C-x C-b.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC

** Moving windows and buffers

   I like to be able to move windows and buffers around quickly and
   for the keys to be quite similar.

   #+BEGIN_SRC emacs-lisp
     (use-package buffer-move
       :ensure t
       :bind (([M-s-up] . buf-move-up)
              ([M-s-down] . buf-move-down)
              ([M-s-right] . buf-move-right)
              ([M-s-left] . buf-move-left)
              ([s-up] . windmove-up)
              ([s-down] . windmove-down)
              ([s-right] . windmove-right)
              ([s-left] . windmove-left)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :init (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
       :bind ("M-o". ace-window))
   #+END_SRC

** workspaces

   I'm giving eyebrowse a try to see if it means that I can have fewer
   frames and more workspaces.

   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse ; Easy workspaces creation and switching
       :ensure t
       :init (setq eyebrowse-mode-line-separator " "
                   eyebrowse-keymap-prefix (kbd "C-c M-w")
                   eyebrowse-new-workspace t)
       :config (eyebrowse-mode t))
   #+END_SRC
** yasnippet
   :PROPERTIES:
   :ORDERED:  t
   :END:

   Yet another snippet package, but this one is pretty good so we'll
   use it.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :defer t
       :diminish yas-minor-mode
       :config (yas-global-mode 1))
   #+END_SRC

** password store

   As said in the header of the mode:

   "This package provides functions for working with pass ("the
   standard Unix password manager")."


   #+BEGIN_SRC emacs-lisp
     (use-package password-store
       :ensure t)
   #+END_SRC

*** And pass to browse it all

    #+BEGIN_SRC emacs-lisp
      (use-package pass
        :ensure t)
    #+END_SRC

** pivotal tracker

   I've tried managing the whole team using org-mode. Even when there
   were only 4 of us and 3 of us were regular emacs users it didn't
   work. It was a lovely idea and I'll give something similar another
   crack.

   For now, we've gone full hipster with [[http://pivotaltracker.com][Pivotal Tracker]].

   #+BEGIN_SRC emacs-lisp
     (use-package pivotal-tracker
       :ensure t)
   #+END_SRC

   And I want it to play nicely with org-mode links

   #+BEGIN_SRC emacs-lisp
     (require 'org-pivotal)
   #+END_SRC

** Emojis

   Just the unicode and github ones really. I like the ascii ones as
   they are :-) .

   #+BEGIN_SRC emacs-lisp
     (use-package emojify
       :ensure t
       :defer t
       :init (add-hook 'after-init-hook #'global-emojify-mode))
   #+END_SRC

** Alerting and Other Status Things

*** alert

    #+BEGIN_SRC emacs-lisp
      (use-package alert
        :commands (alert)
        :init
        (setq alert-default-style 'notifications))
    #+END_SRC

*** The Great Eye of Sauron

    #+BEGIN_SRC emacs-lisp
      (use-package sauron
        :ensure t
        :config (setq sauron-separate-frame nil
                      sauron-prio-twittering-new-tweets 2))
    #+END_SRC

** expand-region

   Looks like a cool way to expand what it is that you want to
   select.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :bind (("C-=" . er/expand-region)))
   #+END_SRC

** paradox

   Get more information when choosing new modes.

   #+BEGIN_SRC emacs-lisp
     (use-package paradox
       :ensure t
       :config (paradox-enable))
   #+END_SRC
* Finishing

** Finis

   I should really come up with better exhortations than this. The
   stuff that Sam Aaron has in emacs-live I actually find quite
   inspirational. cider.el has similar, though more specifically
   clojurian things to say that I quite like as well.

   However, I've always expected that any sufficiently advanced lisp
   system has probably gained sentience. I think Emacs probably
   qualifies for that.

   Therefore, let's sign off as so...

   #+BEGIN_SRC emacs-lisp
     (message "Cogito ergo sum.")
   #+END_SRC

** Extra Bits

   #+BEGIN_EXAMPLE

     (add-to-list 'mu4e-bookmarks
                  '("maildir:\"/otfrom/[Gmail].All Mail\" \\\\Inbox" "otfrom inbox" ?o))

     (add-to-list 'mu4e-bookmarks
                  '("maildir:\"/mastodonc/[Gmail].All Mail\" \\\\Inbox" "mastodonc inbox" ?m))


   #+END_EXAMPLE
