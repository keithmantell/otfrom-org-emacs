* Helpers

  There are a number of helper functions that we'll need through the
  rest of this. We'll just define them up here.

** load-if-exists

   This is just a nice function to load a file if it exists, but just
   print a message rather than an error if it doesn't. This is handy
   for things like loading specific local config that you don't want
   to go into github or be shared such as erc nicks, passwords, blog
   rolls, etc.

   #+BEGIN_SRC emacs-lisp
     (defun load-if-exists (file)
       (if (file-exists-p file)
           (progn
             (load file)
             (message (format "Loading file: %s" file)))
         (message (format "No %s file. So not loading one." file))))
   #+END_SRC

** add-to-hooks

   A little helper function to make adding things to hooks easier.

   #+BEGIN_SRC emacs-lisp
     (defun bld/add-to-hooks (f hooks)
       "Add funcion F to all HOOKS."
       (dolist (hook hooks)
         (add-hook hook f)))
   #+END_SRC

* Version Control with magit and Diffing with ediff

  Once we have things up and running, really the most basic thing is
  version control. This allows us to add everything else we need in an
  organised manner. Once we have this we can bootstrap everything
  else.

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :bind (("C-c g" . magit-status)))
  #+END_SRC

  Once we do have version control and can do things with ediff, which
  is a great mode for looking at diffs between versions, buffer, files
  and directory trees, I want to fix how the windows work as the
  default annoys me when it creates separate frames. I'd much rather
  move around windows inside the one emacs frame.

  #+BEGIN_SRC emacs-lisp
    (use-package ediff
      :config
      (setq ediff-window-setup-function 'ediff-setup-windows-plain))
  #+END_SRC

** Delete that trailing whitespace

   Trailing whitespace just causes trouble with diffs and version
   control. So let's get rid of it.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook
               (lambda nil
                 (delete-trailing-whitespace)))
   #+END_SRC

* Make it pretty

** Colours

   It seems trivial, but it is one of the first things I do after I
   get the basics up and running. I like to get my colours and other
   basic window chrome and geegaws right.

   #+BEGIN_SRC emacs-lisp
     (load-theme 'wheatgrass)
   #+END_SRC

** Bars, columns and lines

   I don't want a tool bar or a scroll bar ever and I don't want a
   menu when I'm in a terminal window.  I do like the menu ot discover
   new things and keybindings when I'm using emacs as an X
   application.

   #+BEGIN_SRC emacs-lisp
     ;; no toolbar
     (tool-bar-mode -1)

     ;; no menu in a terminal
     (unless window-system
       (menu-bar-mode -1))

     ;; no scroll bar
     (scroll-bar-mode -1)

     ;; no horizontal scroll bar
     (when (boundp 'horizontal-scroll-bar-mode)
       (horizontal-scroll-bar-mode -1))
   #+END_SRC

   I also like to have an idea of where I am in the file so I'd like
   line and column numbers.

   #+BEGIN_SRC emacs-lisp
     (line-number-mode 1)
     (column-number-mode 1)
   #+END_SRC
** Startup Screen

   I'd also like to skip the startup screen and go straight to the
   *scratch* buffer.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
   #+END_SRC

* Programming

  Configuring emacs is lisp coding. When I'm not coding in emacs-lisp,
  I'm usually coding in clojure. I'd like to try to get get nice
  environments for both as quickly as possible.

** Helping in all modes

   Some minor modes just help with programming everywhere.

*** company

    This is the best completion package available in emacs at the
    moment. It works with most programming modes.

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :config
        (global-company-mode))
    #+END_SRC

*** projectile

    Projectile allows you to treat gropus of files under git control
    or other build tools as projects and navigate and search them in
    easier ways.

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :diminish projectile-mode
        :config
        (setq projectile-enable-caching t)
        (projectile-global-mode 1))
    #+END_SRC

*** tabs are evil

    They are, they just are. I spent time putting those characters in
    the right place. I don't want you to change that.

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+END_SRC

** Lisps

   I am a big fan of lisps. I like the syntax and some of the
   communities now a days are very nice places to be in.

   At the moment most of my lisp work is either in emacs-lisp or in
   clojure.

   Below are the ways I configure various lisp modes.

*** Lisp Hooks

    There are a number of related lisp modes and I'd like to make a
    them behave the same (when that makes sense anyway).

    #+BEGIN_SRC emacs-lisp
      (defvar lisp-mode-hooks
        '(emacs-lisp-mode-hook lisp-mode-hook clojure-mode-hook))

      (defvar lisp-interaction-mode-hooks
        '(lisp-interaction-modes-hook cider-mode-hook cider-repl-mode-hook))
    #+END_SRC

**** Indent all the things... aggressively

     I love this mode when doing lisp stuff. It really makes it
     obvious when you don't have things balanced up and keeps your
     code tidy.

     #+BEGIN_SRC emacs-lisp
       (use-package aggressive-indent
         :ensure t
         :diminish aggressive-indent-mode
         :config (bld/add-to-hooks #'aggressive-indent-mode lisp-mode-hooks))
     #+END_SRC

**** eldoc so you know what is going on

     eldoc is another great little tip so that you can see what the
     signature is for the functions you are using.

     #+BEGIN_SRC emacs-lisp
       (use-package eldoc
         :diminish eldoc-mode
         :config (bld/add-to-hooks #'eldoc-mode
                                   (append lisp-mode-hooks lisp-interaction-mode-hooks)))
     #+END_SRC

**** paredit

     I *always* want my parens to match (except in text modes).

     #+BEGIN_SRC emacs-lisp
       (use-package paredit
         :ensure t
         :diminish paredit-mode
         :config (bld/add-to-hooks #'paredit-mode
                                   (append lisp-mode-hooks lisp-interaction-mode-hooks)))
     #+END_SRC

**** rainbow delimiters

     All of those delimeters should be pretty and give you a hint as
     to where they match.

     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters
         :ensure t
         :diminish rainbow-delimiters
         :config (bld/add-to-hooks #'rainbow-delimiters-mode
                                   (append lisp-mode-hooks lisp-interaction-mode-hooks)))
     #+END_SRC

**** Paren matching

     Because you really need to see where those things match.

     #+BEGIN_SRC emacs-lisp
       (use-package paren
         :config (bld/add-to-hooks #'show-paren-mode
                                   (append lisp-mode-hooks lisp-interaction-mode-hooks)))
     #+END_SRC

*** clojure and CIDER

    Clojure is certainly my favorite lisp on the JVM and is the one I
    use most professionally, or at least the one I create code in that
    I ship to other people.

    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :defer t
        :mode (("\\.clj\\'" . clojure-mode)
               ("\\.edn\\'" . clojure-mode)))
    #+END_SRC

    CIDER is the mode that lets us connect to a REPL and evaluate code
    and do REPL Driven Development.

    #+BEGIN_SRC emacs-lisp
      (use-package cider
        :ensure t
        :defer t
        :config
        (setq cider-repl-history-file (concat user-emacs-directory "cider-history")
              cider-repl-history-size 1000
              cider-font-lock-dynamically '(macro core function var)
              cider-overlays-use-font-lock t
              cider-pprint-fn 'fipp
              cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))"))
    #+END_SRC

    clj-refactor lets us move a lot of things around and get less
    often used bits of syntax like ns declrations correct.

    #+BEGIN_SRC emacs-lisp
      (use-package clj-refactor
        :ensure t
        :defer t
        :config
        (defun my-clj-refactor-hook ()
          (message "Running cljr hook.")
          (clj-refactor-mode 1)
          (cljr-add-keybindings-with-prefix "C-c r"))
        (add-hook 'clojure-mode-hook 'my-clj-refactor-hook))
    #+END_SRC

* Text Modes

** Text Mode Basics

   If we are in a text mode we want flyspell and auto-fill-mode.

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :diminish flyspell-mode
       :config (add-hook 'text-mode-hook
                         (lambda () (flyspell-mode 1))))
   #+END_SRC

   auto-fill-mode & text-mode is a bit weird and I've really not found
   a way to make it play nicely with use-package they way I've done
   the other minor modes. So I've just gone old school here.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook
               (lambda ()
                 (auto-fill-mode 1)
                 (diminish auto-fill-function)))
   #+END_SRC

** Markdown

   Not everything is done in org-mode. Though perhaps it should be.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode (".md$" . gfm-mode))
   #+END_SRC

* Other Modes

** ido and smex

   I just want to use this everywhere. I've tried using helm before
   for a similar purpose and while it is really good I found it a bit
   too intrusive. This might be because I am interface damaged from
   years of using emacs, but this is my config if you want to go wild
   with helm, then create your own. ;-)

   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :ensure t
       :bind (("M-x" . smex))
       :config (smex-initialize))  ; smart meta-x (use IDO in minibuffer)

     (use-package ido
       :ensure t
       :demand t
       :bind (("C-x b" . ido-switch-buffer))
       :config (ido-mode 1)
       (setq ido-create-new-buffer 'always  ; don't confirm when creating new buffers
             ido-enable-flex-matching t     ; fuzzy matching
             ido-everywhere t  ; tbd
             ido-case-fold t)) ; ignore case

     (use-package ido-ubiquitous
       :ensure t
       :config (ido-ubiquitous-mode 1))

     (use-package flx-ido
       :ensure t
       :config (flx-ido-mode 1))

     (use-package ido-vertical-mode
       :ensure t
       :config (ido-vertical-mode 1))
   #+END_SRC

** yasnippet

   Yet another snippet package, but this one is pretty good so we'll
   use it.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :defer t
       :config (yas-global-mode 1))
   #+END_SRC

** password store

   As said in the header of the mode:

   "This package provides functions for working with pass ("the
   standard Unix password manager")."


   #+BEGIN_SRC emacs-lisp
     (use-package password-store
       :ensure t)
   #+END_SRC

** irc/slack and erc stuff

   erc can be used for irc and as a slack client. It needs a few
   things to make it a bit nicer even though it is actually pretty
   good out of the box.

   #+BEGIN_SRC emacs-lisp
     (use-package erc-colorize
       :ensure t
       :defer t
       :config (erc-colorize-mode 1))
   #+END_SRC

** pivotal tracker

   I've tried managing the whole team using org-mode. Even when there
   were only 4 of us and 3 of us were regular emacs users it didn't
   work. It was a lovely idea and I'll give something similar another
   crack.

   For now, we've gone full hipster with [[http://pivotaltracker.com][Pivotal Tracker]].

   #+BEGIN_SRC emacs-lisp
     (use-package pivotal-tracker
       :ensure t)
   #+END_SRC

** twittering-mode

   I have been accused by many ([[http://twitter.com/rrees][Robert Rees]] and [[http://twitter.com/cluttercup][Jane Dickson]] to name
   but two) of being constantly on twitter. This is mostly fair. I'm
   curious to see the revision history of this file and see if I
   change this description before I declare .emacs bankruptcy again.

   The best twitter client I've found is twittering-mode.

   #+BEGIN_SRC emacs-lisp
     (use-package twittering-mode
       :ensure t
       :defer t
       :bind (([M-f6] . twittering-update-status-interactive))
       :config (setq twittering-url-show-status nil
                     twittering-icon-mode 1
                     twittering-use-icon-storage t
                     twittering-use-master-password t
                     twittering-initial-timeline-spec-string
                     '("otfrom/people-i-know"
                       ":replies"
                       ":direct_messages")
                     twittering-timer-interval (* 60 30))
       (add-hook 'twittering-edit-mode-hook
                 (lambda () (ispell-minor-mode) (flyspell-mode))))
   #+END_SRC

** Emojis

   Just the unicode and github ones really. I like the ascii ones as
   they are :-) .

   #+BEGIN_SRC emacs-lisp
     (use-package emojify
       :ensure t
       :defer t
       :config (add-hook 'after-init-hook #'global-emojify-mode))
   #+END_SRC

* Finishing

** Backups

   Backups are handy for those times where you run out of power
   suddenly or you get a kernel panic, but it isn't fun having them
   littered around the system.

   #+BEGIN_SRC emacs-lisp
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
   #+END_SRC

** Enabling the disabled

*** upcase and downcase region

    I like to be able to do this. I get lots of things that come in
    SHOUTING or that need to SHOUT.

    #+BEGIN_SRC emacs-lisp
      (put 'downcase-region 'disabled nil)
      (put 'upcase-region 'disabled nil)
    #+END_SRC

*** Narrowing the region to what I want to look at

    This isn't needed quite so much now that searches, regexp and
    otherwise operate, sometimes annoyingly to an old timer like me, on
    the region rather than the whole buffer window. I still like to
    narrow down to what I'm interested in though and not every handy
    tool in emacs is quite so region oriented.

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

** custom.el

   custom.el is great for configuring things through that "gui" in
   emacs, but it is a real pain when it drops junk in your [[../init.el][init.el]] and
   messes up your pretty config and git history and is stuff that you
   don't want to leak out on to github. You can change the location of
   this file though and I like to do this.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "local/custom.el"))
     (load-if-exists custom-file)
   #+END_SRC

** passwords and encrypted things

   It is good to store your passwords and things in an encrypted
   file. I call mine mellon, because you can only read it if you are
   my friend and have the passphrase.

   This does mean that every time you use it you have to give the
   passphrase, but it does mean that you can keep all your passwords
   for things like erc and stuff in a file reasonably safely (though
   it will be in memory when emacs is running, so it isn't completely
   secure).

   #+BEGIN_SRC emacs-lisp
     (load-if-exists (concat user-emacs-directory "local/mellon.el.gpg"))
   #+END_SRC

** Finis

   I should really come up with better exhortations than this. The
   stuff that Sam Aaron has in emacs-live I actually find quite
   inspirational. cider.el has similar, though more specifically
   clojurian things to say that I quite like as well.

   However, I've always expected that any sufficiently advanced lisp
   system has probably gained sentience. I think Emacs probably
   qualifies for that.

   Therefore, let's sign off as so...

   #+BEGIN_SRC emacs-lisp
     (message "Cogito ergo sum.")
   #+END_SRC
